---
layout: post
title: Do it! Vue.js 입문 - Vue JS의 특징 / 인스턴스 & 컴포넌트
cover: cover.jpg
---

* * *

<br> 

# Vue JS
<br>
라이브러리의 역할 뿐만 아니라 프레임 워크의 역할까지도 제공

리액트의 장점 - 가상 돔 기반 렌더링 방식, 앵귤러의 장점 - 데이터 바인딩의 두가지를 모두 가지면서
더 좋은 퍼포먼스를 보인다

```
	가상돔 ?
	var CommentBox = React.createClass({
		render: function() {
		return (
			<div className="commentBox">
				Hello, world! I am a CommentBox.
			</div>
			);
		}
	});
```

# Vue JS의 특징
<br>

* MVVM(Model-View-ViewModel)패턴의 뷰 모델
* 컴포넌트 기반 프레임 워크
* 앵귤러의 양방향 데이터 바인딩 + 리액트의 단방향 데이터 흐름

```
        MVVM? 
        프런트엔드딴의 로직과 백엔드딴의 로직을 완전 분리한다.
```
<br>

# 뷰 인스턴스
</br>

### 정의 
</br>

     Vue로 화면을 개발하기 위해 필수적으로 생성해야하는 기본 단위
</br>

### 형식 
</br>

        new Vue({
            ...
        });
    예)
        new Vue({
            el: '#app',                 --> el 속성
            data: {                     --> data속성
                message: 'Hello Vue.js' 
            }
        });
</br>

### 생성자

 </br>

        new Vue();
        뷰라이브러리를 로딩하고 나면 접근 가능.
        필요한 기능을 생성자에 미리 정의해놓고 사용자가 그 기능을 재정의하여 편리하게 사용하기위해 사용
</br>

### 속성 
</br>

        예) data, el, template, method, created ...

        el : Vue로 만든 화면이 시작되는 시작점, 화면을 렌더링할때 화면이 그려질 위치의 돔 요소를 지정해야한다.
        (el : '#app' -> 돔 요소중 app이라는 id가진 요소, CSS선택자 규칙과 같음)
        template : 화면에 표시할 HTML,CSS등의 마크업 요소를 정의하는 속성
        methods : 화면 로직제어 와 관계된 메서드 정의. 클릭이벤트처리와 같은 이벤트와 화면 동작과 관련된 로직 추가 가능
        created : 뷰 인스턴스가 생성되자마자 실행할 로직을 정의할 수 있는 속성
</br>

### 인스턴스 유효 범위 
</br>

        인스턴스 생성시 옵션 속성들이 적용되는 HTML의 특정 범위, el속성과 밀접하게 관계

        인스턴스 생성된 후 화면에 옵션을 적용하는 과정
            뷰 라이브러리 파일 로딩 -> 인스턴스 객체 생성 -> 특정화면요소에 인스턴스 붙임 
            -> 인스턴스 내용이 화면 요소로 변환 -> 변환된 화면 요소를 사용자가 확인

        인스턴스 에서 el에 지정한 태그의 바깥 범위에서는 인식 못한다.
</br>

### 인스턴스 라이프 사이클 
</br>

        라이프 사이클 속성 : 인스턴스 상태에 따라 호출할 수 있는 속성
        라이프 사이클 훅 : 각 라이프사이클 속성에서 실행되는 커스텀 로직

        인스턴스 생성
        |   이벤트 및 라이프 사이클 초기화
        |       beforeCreate
        |   화면에 반응성 주입
        |       created
        |   el, template 속성 확인
        |   template속성을 render()로 반환
        |       beforeMount
        |   $el 생성 후 el 속성값을 대입
        |       mounted
        인스턴스 화면 부착                         ------데이터가 변경되는 경우만 실행 -------
        |   인스턴스의 데이터 변경                                    
        |       beforeUpdate                                       
        |   화면 재 렌더링 및 데이터 갱신                            
        |       updated                                       
        인스턴스 내용 갱신                         ------데이터가 변경되는 경우만 실행 -------
        |   인스턴스 접근 가능
        |       beforeDestroy
        |   컴포넌트, 인스턴스 디렉티브 등 모두 해체
        |       destroy
        인스턴스 소멸

        created
            data 속성과 methods속성이 정의되어 있어서 this.data와 같은 로직으로 속성에 정의된 값에 접근 가능
            그러나 화면요소에 부착되기전이기 때문에 template 속성에 정의된 돔 요소로 접근은 불가
            data속성, methods속성에 접근할 수 있는 가장 첫 라이프사이클 단계이므로 서버에서 데이터를
            받아오는 로직을 수행하기 좋음

        beforeMount 
            template 속성에 지정한 마크업 속성을 render()함수로 변환한 후 el속성에 인스턴스를 부착하기 전에 호출되는 단계
            render() 함수가 호출되기 직전 로직 추가

        mounted
            el 속성에서 지정한 화면 요소에 인스턴스가 부착되고 나면 호출되는 단계
            template 속성에 정의한 화면요소에 접근할 수 있어 화면 요소를 제어하는 로직 추가
            돔에 인스턴스가 부착되자마자 바로 호출되기 때문에 하위 컴포넌트나 외부라이브러리로 추가된 화면 요소들이
            HTML코드로 변환되는 시점과 차이가 있음

        beforeUpdate -> 데이터값을 갱신하는 로직
            beforeUpdate는 관찰하고 있는 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출되는 단계,
            변경 예정인 새 데이터에 접근할 수 있어 ㅂ젼경 예정 데이터값에 관련된 로직 추가 가능 -> 화면이 재구성되지는 않음

            데이터 관찰
            el 속성한 지정한 화면 요소에 인스턴스가 부착된 후에 인스턴스의 속성들이 화면에 치환된다.
            이때 최한된 값은 뷰의 반응성을 제공하기위해 $watch속성으로 감시 하는 것
            (뷰의 반응성 - 코드의 변화에 따라 화면이 반사적으로 반응하여 빠르게 화면을 갱신하는 것)

        updated -> 변경데이터의 화면 요소와 관련된 로직
            데이터 변경 후 가상 돔으로 다시 화면을 그리고 나서 실행되는 단계.
            데이터의 변경 후에 화면 제어 관련된 로직 추가하기 좋음.
            이 단계에서 데이터 값을 변경하게 되면 무한루프에 빠질 수가 있음.(computed, watch와 같은 속성 사용)
</br>

## 뷰 컴포넌트 
</br>

    조합하여 화면을 구성할 수 있는 블록
    화면을 빠르게 구조화하여 일관적인 패턴으로 개발 가능
    코드 재사용 및 직관적인 다른사람의 코드 이해 가능
    뷰에서는 테이블, 리스트, 인풋박스등 과 같은 화면 구성 요소들을 쪼개에 컴포넌트로 관리
    트리 구조와 유사
</br>

### 전역 컴포넌트 
</br>

        등록 : 컴포넌트명은 template속성에서 사용할 HTML 사용자 정의 태그명
            Vue.component('my-component', {
                template : '<div>전역 컴포넌트 등록</div>'
            });

        사용 : 
            <body>
                <my-component></my-component>
            </body>
</br>

### 지역 컴포넌트 
</br>

        등록 : 
            var cmp = {
                template: '<div>지역 컴포넌트 등록</div>'
            };
            new Vue({
                el : '#app',
                components: {
                    'my-local-component' : cmp
                }
            });
</br>

## 뷰 컴포넌트 통신 

</br>

    한 화면을 하나의 View로 간주해서 한 화면의 데이터를 어디서나 호출하던 기존과 달리 뷰는 컴포넌트로 화면을 구성해서
    같은 화면이라도 데이터를 공유할 수 없음.
    컴포넌트 마다 각자의 고유한 유효 범위를 가지기 때문.

</br>

### 상 하위 컴포넌트 간 통신  
</br>

        부모 -> 자식 props 라는 속성을 전달
        자식 -> 부모 이벤트만 전달 (이벤트와 함께 데이터를 전달하고 시픙면 이벤트의 두번째 인자값이나 이벤트 버스를 활용)

        props 속성 (부모 -> 자식)
            자식 컴포넌트에 속성 정의
                {
                    props:['prop속성 이름'],
                }
            부모 HTML코드에 등록한 자식 컴포넌트 태그에 v-bild 속성 추가
                <child-component v-bind:props 속성이름="상위 컴포넌트의 data속성"></child=component>

        event (자식 -> 부모)
            자식 컴포넌트에서 $emit(); 을 사용하여 이벤트 발생
                this.$emit('이벤트명');
            부모 HTML코드에 등록한 자식 컴포넌트 태그에 v-on 속성 추가
                <child-component v-on:이벤트명="상위 컴포넌트의 메서드명"></child=component>
</br>

### 같은 레벨의 컴포넌트 간 통신 
</br>

        공통 상위 컴포넌트로 이벤트 발생 후 공통 상위 컴포넌트에서 2개의 하위 컴포넌트로 props를 내려보냄
        이러면 상위 컴포넌트가 필요없도 통신을 위해서 무조건 만들어야 하는 단점 => 이벤트 버스 사용

        새로운 인스턴스를 하나 생성
            var eventBus = new Vue();
        이벤트를 보내는 컴포넌트 
            eventBus.$emit('이벤트명', 데이터);
        이벤트를 받는 컴포넌트
            eventBus.$on('이벤트명', functino(데이터) {
                ...
            });
